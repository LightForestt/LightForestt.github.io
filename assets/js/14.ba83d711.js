(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{367:function(o,t,e){"use strict";e.r(t);var l=e(44),a=Object(l.a)({},(function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("h2",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[o._v("#")]),o._v(" vue")]),o._v(" "),e("blockquote",[e("p",[o._v("等待添加")])]),o._v(" "),e("h2",{attrs:{id:"vue-router"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[o._v("#")]),o._v(" vue-router")]),o._v(" "),e("ul",[e("li",[e("code",[o._v("window.history.pushState")]),o._v(" adds a state to the browser's session history stack.在历史栈添加一个路由状态。")])]),o._v(" "),e("p",[o._v("举个例子：假设初始 url"),e("code",[o._v("http://mozilla.org/foo.html")]),o._v(",执行代码"),e("code",[o._v('history.pushState({foo:bar}, "page 2", "bar.html")')]),o._v("，将导致显示 URL 栏"),e("code",[o._v("http://mozilla.org/bar.html")]),o._v("，但**"),e("em",[o._v("不会")]),o._v("**导致浏览器加载 bar.html,也不会检查 bar.html 是否存在。现在假设现在用户再次跳转到http://google.com。对比如下两种回退操作的区别： - 首次单击上一步按钮。此时，URL 栏将显示"),e("code",[o._v("http://mozilla.org/bar.html")]),o._v("并且"),e("code",[o._v("history.state")]),o._v("包含{foo:bar}这个对象。popstate 事件不会被触发，因为是页面被重新加载而不是在 mozilla 内部进行跳转,是从 google 跳转到 mozilla。 - 如果用户再次点击上一步，此时是在 mozilla 内部进行回退，此时"),e("code",[o._v("history.state")]),o._v("栈顶元素弹出，这时候会触发 popState 事件。 - 每个 state 对应一个对应的 url。")]),o._v(" "),e("ul",[e("li",[e("code",[o._v("window.history.replaceState")]),o._v(" modifies the current history entry, 修改当前历史栈栈顶元素 。\n举个例子：假设现在地址栏 "),e("code",[o._v("https://www.mozilla.org/foo.html")]),o._v("，然后使用 "),e("code",[o._v('history.pushState({foo:bar}, "page 2", "bar0.html")')]),o._v("添加 bar0.html 到地址栏中 地址栏变为 "),e("code",[o._v("https://www.mozilla.org/bar0.html")]),o._v("此时调用"),e("code",[o._v("history.replaceState(stateObj, '', 'bar2.html')")]),o._v(" 会让路由地址"),e("code",[o._v("https://www.mozilla.org/bar2.html")]),o._v(" 如此展示，同样的，也不会检测 bar2.html 是不是存在更不会加载它，然后点击返回上一步或者 go(-1) 会发现页面并没有回到 bar0 ，而是直接跳转到了 foo 。")])]),o._v(" "),e("ul",[e("li",[e("code",[o._v("window.location.assign")]),o._v("方法会触发窗口加载并显示指定的 URL 的内容,栈顶添加一条历史记录。")]),o._v(" "),e("li",[e("code",[o._v("window.location.replace")]),o._v("方法以给定的 URL 来替换当前的资源。 与 assign() 方法 不同的是，调用 replace() 方法后，当前页面不会保存到会话历史中（session History），这样，用户点击回退按钮时，将不会再跳转到该页面。替换当前栈顶元素。")])]),o._v(" "),e("ul",[e("li",[e("code",[o._v("window.scrollTo")]),o._v(" 滚动到特定元素点")]),o._v(" "),e("li",[e("code",[o._v("window.scroll")]),o._v(" 同上")]),o._v(" "),e("li",[e("code",[o._v("window.scrollBy")]),o._v(" 滚动特定距离\n上述三个方法都接受同样的参数 - (options)配置 包含三项{x,y,isSmooth} - (x,y) x y 要滚动的像素数，表示你想要置于文档左上角的像素点的横纵坐标。 - 对于 scrollBy 就代表滚动的 x y 的距离。")])]),o._v(" "),e("ul",[e("li",[e("code",[o._v("window.addEventListener('popstate',()=>{})")]),o._v("当活动历史记录条目更改时，将触发 popstate 事件。如果被激活的历史记录条目是通过对 history.pushState（）的调用创建的，或者受到对 history.replaceState（）的调用的影响，popstate 事件的 state 属性包含历史条目的状态对象的副本。也就是第二个参数，保存了当前 url 对应的特定数据。需要注意的是调用 history.pushState()或 history.replaceState()不会触发 popstate 事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用 history.back()或者 history.forward()方法，go(-1)）")])]),o._v(" "),e("ul",[e("li",[e("code",[o._v("window.addEventListener('hashChange',()=>{})")]),o._v("当 URL 的片段标识符更改时，将触发 hashchange 事件 (跟在＃符号后面的 URL 部分，包括＃符号),")])]),o._v(" "),e("ul",[e("li",[e("code",[o._v("window.pageXOffset")]),o._v(" scrollX 的别名 水平方向已经滚动的距离")]),o._v(" "),e("li",[e("code",[o._v("window.pageYOffset")]),o._v(" scrollY 的别名 垂直方向已经滚动的距离")]),o._v(" "),e("li",[e("code",[o._v("Element.scrollTop")]),o._v("属性可以获取或设置一个元素的内容垂直滚动的像素数。一个元素的 scrollTop 值是这个元素的内容顶部（卷起来的）到它的视口可见内容（的顶部）的距离。\n"),e("ul",[e("li",[o._v("当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为 0。")]),o._v(" "),e("li",[o._v('如果一个元素不能被滚动（例如，它没有溢出，或者这个元素有一个"non-scrollable"属性）， scrollTop 将被设置为 0。')]),o._v(" "),e("li",[o._v("设置 scrollTop 的值小于 0，scrollTop 被设为 0")]),o._v(" "),e("li",[o._v("如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值。")])])])]),o._v(" "),e("ul",[e("li",[e("code",[o._v("HTMLElement.getBoundingClientRect")]),o._v("方法返回元素的大小及其相对于视口的位置。")])]),o._v(" "),e("h2",{attrs:{id:"vue-lazyload"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-lazyload"}},[o._v("#")]),o._v(" vue-lazyLoad")]),o._v(" "),e("blockquote",[e("p",[o._v("等待添加")])])])}),[],!1,null,null,null);t.default=a.exports}}]);